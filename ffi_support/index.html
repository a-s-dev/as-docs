<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `ffi_support` crate."><meta name="keywords" content="rust, rustlang, rust-lang, ffi_support"><title>ffi_support - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../ffi_support/index.html'><div class='logo-container'><img src='../rust-logo.png' alt='logo'></div></a><p class='location'>Crate ffi_support</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all ffi_support's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#traits">Traits</a></li><li><a href="#functions">Functions</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'ffi_support', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/ffi_support/lib.rs.html#17-478' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>ffi_support</a></span></h1><div class='docblock'><h1 id="ffi-support" class="section-header"><a href="#ffi-support">FFI Support</a></h1>
<p>This crate implements a support library to simplify implementing the patterns that the
<code>mozilla/application-services</code> repository uses for it's &quot;Rust Component&quot; FFI libraries.</p>
<p>It is <em>strongly encouraged</em> that anybody writing FFI code in this repository read this
documentation before doing so, as it is a subtle, difficult, and error prone process.</p>
<h2 id="terminology" class="section-header"><a href="#terminology">Terminology</a></h2>
<p>For each library, there are currently three parts we're concerned with. There's no clear correct
name for these, so this documentation will attempt to use the following terminology:</p>
<ul>
<li>
<p><strong>Rust Component</strong>: A Rust crate which does not expose an FFI directly, but may be may be
wrapped by one that does. These have a <code>crate-type</code> in their Cargo.toml (see
https://doc.rust-lang.org/reference/linkage.html) of <code>lib</code>, and not <code>staticlib</code> or <code>cdylib</code>
(Note that <code>lib</code> is the default if <code>crate-type</code> is not specified). Examples include the
<code>fxa-client</code>, and <code>logins</code> crates.</p>
</li>
<li>
<p><strong>FFI Component</strong>: A wrapper crate that takes a Rust component, and exposes an FFI from it.
These typically have <code>ffi</code> in the name, and have <code>crate-type = [&quot;lib&quot;, &quot;staticlib&quot;, &quot;cdylib&quot;]</code>
in their Cargo.toml. For example, the <code>fxa-client/ffi</code> and <code>logins/ffi</code> crates (note:
paths are subject to change). When built, these produce a native library that is consumed by
the &quot;FFI Consumer&quot;.</p>
</li>
<li>
<p><strong>FFI Consumer</strong>: This is a low level library, typically implemented in Kotlin (for Android)
or Swift (for iOS), that exposes a memory-safe wrapper around the memory-unsafe C API produced
by the FFI component. It's expected that the maintainers of the FFI Component and FFI Consumer
be the same (or at least, the author of the consumer should be completely comfortable with the
API exposed by, and code in the FFI component), since the code in these is extremely tightly
coupled, and very easy to get wrong.</p>
</li>
</ul>
<p>Note that while there are three parts, there may be more than three libraries relevant here, for
example there may be more than one FFI consumer (one for Android, one for iOS).</p>
<h2 id="usage" class="section-header"><a href="#usage">Usage</a></h2>
<p>This library will typically be used in both the Rust component, and the FFI component, however
it frequently will be an optional dependency in the Rust component that's only available when a
feature flag (which the FFI component will always require) is used.</p>
<p>The reason it's required inside the Rust component (and not solely in the FFI component, which
would be nice), is so that types provided by that crate may implement the traits provided by
this crate (this is because Rust does not allow crate <code>C</code> to implement a trait defined in crate
<code>A</code> for a type defined in crate <code>B</code>).</p>
<p>In general, examples should be provided for the most important types and functions
([<code>call_with_result</code>], [<code>IntoFfi</code>],
[<code>ExternError</code>], etc), but you should also look at the code of
consumers of this library.</p>
<h3 id="usage-in-the-rust-component" class="section-header"><a href="#usage-in-the-rust-component">Usage in the Rust Component</a></h3>
<p>Inside the Rust component, you will implement:</p>
<ol>
<li>
<p>[<code>IntoFfi</code>] for all types defined in that crate that you want to return
over the FFI. For most common cases, the [<code>implement_into_ffi_by_json!</code>] and
[<code>implement_into_ffi_by_protobuf!</code>] macros will do the job here, however you
can see that trait's documentation for discussion and examples of
implementing it manually.</p>
</li>
<li>
<p>Conversion to [<code>ExternError</code>] for the error type(s) exposed by that
rust component, that is, <code>impl From&lt;MyError&gt; for ExternError</code>.</p>
</li>
</ol>
<h3 id="usage-in-the-ffi-component" class="section-header"><a href="#usage-in-the-ffi-component">Usage in the FFI Component</a></h3>
<p>Inside the FFI component, you will use this library in a few ways:</p>
<ol>
<li>
<p>Destructors will be exposed for each types that had [<code>implement_into_ffi_by_pointer!</code>] called
on it (using [<code>define_box_destructor!</code>]), and a destructor for strings should be exposed as
well, using [<code>define_string_destructor</code>]</p>
</li>
<li>
<p>The body of every / nearly every FFI function will be wrapped in either a
[<code>call_with_result</code>] or [<code>call_with_output</code>].</p>
<p>This is required because if we <code>panic!</code> (e.g. from an <code>assert!</code>, <code>unwrap()</code>, <code>expect()</code>, from
indexing past the end of an array, etc) across the FFI boundary, the behavior is undefined
and in practice very weird things tend to happen (we aren't caught by the caller, since they
don't have the same exception behavior as us).</p>
<p>If you don't think your program (or possibly just certain calls) can handle panics, you may
also use the versions of these functions in the [<code>abort_on_panic</code>] module, which
do as their name suggest.</p>
</li>
</ol>
<p>Additionally, c strings that are passed in as arguments may be represented using [<code>FfiStr</code>],
which contains several helpful inherent methods for extracting their data.</p>
</div><h2 id='reexports' class='section-header'><a href="#reexports">Re-exports</a></h2>
<table><tr><td><code>pub use crate::handle_map::<a class="struct" href="../ffi_support/handle_map/struct.ConcurrentHandleMap.html" title="struct ffi_support::handle_map::ConcurrentHandleMap">ConcurrentHandleMap</a>;</code></td></tr><tr><td><code>pub use crate::handle_map::<a class="struct" href="../ffi_support/handle_map/struct.Handle.html" title="struct ffi_support::handle_map::Handle">Handle</a>;</code></td></tr><tr><td><code>pub use crate::handle_map::<a class="enum" href="../ffi_support/handle_map/enum.HandleError.html" title="enum ffi_support::handle_map::HandleError">HandleError</a>;</code></td></tr><tr><td><code>pub use crate::handle_map::<a class="struct" href="../ffi_support/handle_map/struct.HandleMap.html" title="struct ffi_support::handle_map::HandleMap">HandleMap</a>;</code></td></tr></table><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="abort_on_panic/index.html" title='ffi_support::abort_on_panic mod'>abort_on_panic</a></td><td class='docblock-short'><p>This module exists just to expose a variant of [<code>call_with_result</code>] and [<code>call_with_output</code>]
that aborts, instead of unwinding, on panic.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="error/index.html" title='ffi_support::error mod'>error</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="ffistr/index.html" title='ffi_support::ffistr mod'>ffistr</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="handle_map/index.html" title='ffi_support::handle_map mod'>handle_map</a></td><td class='docblock-short'><p>This module provides a [<code>Handle</code>] type, which you can think of something
like a dynamically checked, type erased reference/pointer type. Depending on
the usage pattern a handle can behave as either a borrowed reference, or an
owned pointer.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="into_ffi/index.html" title='ffi_support::into_ffi mod'>into_ffi</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="macros/index.html" title='ffi_support::macros mod'>macros</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="mod" href="string/index.html" title='ffi_support::string mod'>string</a></td><td class='docblock-short'></td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.define_box_destructor.html" title='ffi_support::define_box_destructor macro'>define_box_destructor</a></td><td class='docblock-short'><p>Define a (public) destructor for a type that was allocated by
<code>Box::into_raw(Box::new(value))</code> (e.g. a pointer which is probably opaque).</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.define_bytebuffer_destructor.html" title='ffi_support::define_bytebuffer_destructor macro'>define_bytebuffer_destructor</a></td><td class='docblock-short'><p>Define a (public) destructor for the ByteBuffer type.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.define_handle_map_deleter.html" title='ffi_support::define_handle_map_deleter macro'>define_handle_map_deleter</a></td><td class='docblock-short'><p>Define a (public) destructor for a type that lives inside a lazy_static
[<code>ConcurrentHandleMap</code>].</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.define_string_destructor.html" title='ffi_support::define_string_destructor macro'>define_string_destructor</a></td><td class='docblock-short'><p>For a number of reasons (name collisions are a big one, but, it also wouldn't work on all
platforms), we cannot export <code>extern &quot;C&quot;</code> functions from this library. However, it's pretty
common to want to free strings allocated by rust, so many libraries will need this, so we
provide it as a macro.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.implement_into_ffi_by_delegation.html" title='ffi_support::implement_into_ffi_by_delegation macro'>implement_into_ffi_by_delegation</a></td><td class='docblock-short'><p>Implement IntoFfi for a type by converting through another type.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.implement_into_ffi_by_json.html" title='ffi_support::implement_into_ffi_by_json macro'>implement_into_ffi_by_json</a></td><td class='docblock-short'><p>Implements [<code>IntoFfi</code>] for the provided types (more than one may be passed
in) by converting to the type to a JSON string.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.implement_into_ffi_by_pointer.html" title='ffi_support::implement_into_ffi_by_pointer macro'>implement_into_ffi_by_pointer</a></td><td class='docblock-short'><p>Implements [<code>IntoFfi</code>] for the provided types (more than one may be passed in) by allocating
<code>$T</code> on the heap as an opaque pointer.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.implement_into_ffi_by_protobuf.html" title='ffi_support::implement_into_ffi_by_protobuf macro'>implement_into_ffi_by_protobuf</a></td><td class='docblock-short'><p>Implements [<code>IntoFfi</code>] for the provided types (more than one may be passed in) implementing
<code>prost::Message</code> (protobuf auto-generated type) by converting to the type to a [<code>ByteBuffer</code>].
This [<code>ByteBuffer</code>] should later be passed by value.</p>
</td></tr><tr class='module-item'><td><a class="macro" href="macro.static_assert.html" title='ffi_support::static_assert macro'>static_assert</a></td><td class='docblock-short'><p>Force a compile error if the condition is not met. Requires a unique name
for the assertion for... reasons. This is included mainly because it's a
common desire for FFI code, but not for other sorts of code.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.ByteBuffer.html" title='ffi_support::ByteBuffer struct'>ByteBuffer</a></td><td class='docblock-short'><p>ByteBuffer is a struct that represents an array of bytes to be sent over the FFI boundaries.
There are several cases when you might want to use this, but the primary one for us
is for returning protobuf-encoded data to Swift and Java. The type is currently rather
limited (implementing almost no functionality), however in the future it may be
more expanded.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ErrorCode.html" title='ffi_support::ErrorCode struct'>ErrorCode</a></td><td class='docblock-short'><p>A wrapper around error codes, which is represented identically to an i32 on the other side of
the FFI. Essentially exists to check that we don't accidentally reuse success/panic codes for
other things.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ExternError.html" title='ffi_support::ExternError struct'>ExternError</a></td><td class='docblock-short'><p>Represents an error that occured within rust, storing both an error code, and additional data
that may be used by the caller.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.FfiStr.html" title='ffi_support::FfiStr struct'>FfiStr</a></td><td class='docblock-short'><p><code>FfiStr&lt;'a&gt;</code> is a safe (<code>#[repr(transparent)]</code>) wrapper around a
nul-terminated <code>*const c_char</code> (e.g. a C string). Conceptually, it is
similar to [<code>std::ffi::CStr</code>], except that it may be used in the signatures
of extern &quot;C&quot; functions.</p>
</td></tr></table><h2 id='traits' class='section-header'><a href="#traits">Traits</a></h2>
<table><tr class='module-item'><td><a class="trait" href="trait.IntoFfi.html" title='ffi_support::IntoFfi trait'>IntoFfi</a></td><td class='docblock-short'><p>This trait is used to return types over the FFI. It essentially is a mapping between a type and
version of that type we can pass back to C (<code>IntoFfi::Value</code>).</p>
</td></tr></table><h2 id='functions' class='section-header'><a href="#functions">Functions</a></h2>
<table><tr class='module-item'><td><a class="fn" href="fn.call_with_output.html" title='ffi_support::call_with_output fn'>call_with_output</a></td><td class='docblock-short'><p>Call a callback that returns a <code>T</code> while:</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.call_with_result.html" title='ffi_support::call_with_result fn'>call_with_result</a></td><td class='docblock-short'><p>Call a callback that returns a <code>Result&lt;T, E&gt;</code> while:</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.call_with_result_impl.html" title='ffi_support::call_with_result_impl fn'>call_with_result_impl</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.destroy_c_string.html" title='ffi_support::destroy_c_string fn'>destroy_c_string</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td><td class='docblock-short'><p>Free the memory of a string created by [<code>rust_string_to_c</code>] on the rust heap. If <code>c_string</code> is
null, this is a no-op.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.init_panic_handling_once.html" title='ffi_support::init_panic_handling_once fn'>init_panic_handling_once</a></td><td class='docblock-short'></td></tr><tr class='module-item'><td><a class="fn" href="fn.opt_rust_str_from_c.html" title='ffi_support::opt_rust_str_from_c fn'>opt_rust_str_from_c</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Same as <code>rust_string_from_c</code>, but returns None if <code>c_string</code> is null instead of asserting.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.opt_rust_string_from_c.html" title='ffi_support::opt_rust_string_from_c fn'>opt_rust_string_from_c</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Same as <code>rust_string_from_c</code>, but returns None if <code>c_string</code> is null instead of asserting.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.opt_rust_string_to_c.html" title='ffi_support::opt_rust_string_to_c fn'>opt_rust_string_to_c</a></td><td class='docblock-short'><p>Variant of [<code>rust_string_to_c</code>] which takes an Option, and returns null for None.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.rust_str_from_c.html" title='ffi_support::rust_str_from_c fn'>rust_str_from_c</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Convert a null-terminated C string to a rust <code>str</code>. This does not take ownership of the string,
and you should be careful about the lifetime of the resulting string. Note that strings
containing invalid UTF-8 are replaced with the empty string (for many cases, you will want to
use [<code>rust_string_from_c</code>] instead, which will do a lossy conversion).</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.rust_string_from_c.html" title='ffi_support::rust_string_from_c fn'>rust_string_from_c</a><a title='unsafe function' href='#'><sup>⚠</sup></a></td><td class='docblock-short'><span class="stab deprecated">Deprecated</span><p>Convert a null-terminated C into an owned rust string, replacing invalid UTF-8 with the
unicode replacement character.</p>
</td></tr><tr class='module-item'><td><a class="fn" href="fn.rust_string_to_c.html" title='ffi_support::rust_string_to_c fn'>rust_string_to_c</a></td><td class='docblock-short'><p>Convert a rust string into a NUL-terminated utf-8 string suitable for passing to C, or to things
ABI-compatible with C.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../";window.currentCrate = "ffi_support";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>