initSidebarItems({"enum":[["MaybeCached","MaybeCached is a type that can be used to help abstract over cached and uncached rusqlite statements in a transparent manner."]],"fn":[["default_max_variable_number","Returns SQLITE_LIMIT_VARIABLE_NUMBER as read from an in-memory connection and cached. connection and cached. That means this will return the wrong value if it's set to a lower value for a connection using this will return the wrong thing, but doing so is rare enough that we explicitly don't support it (why would you want to lower this at runtime?)."],["each_chunk","Helper for the case where you have a `&[impl ToSql]` of arbitrary length, but need one of no more than the connection's `MAX_VARIABLE_NUMBER` (rather, `default_max_variable_number()`). This is useful when performing batched updates."],["each_chunk_mapped","A version of `each_chunk` for the case when the conversion to `to_sql` requires an custom intermediate step. For example, you might want to grab a property off of an arrray of records"],["each_sized_chunk",""],["each_sized_chunk_mapped","Utility to help perform batched updates, inserts, queries, etc. This is the low-level version of this utility which is wrapped by `each_chunk` and `each_chunk_mapped`, and it allows you to provide both the mapping function, and the chunk size."],["escape_string_for_pragma","In PRAGMA foo='bar', `'bar'` must be a constant string (it cannot be a bound parameter), so we need to escape manually. According to https://www.sqlite.org/faq.html, the only character that must be escaped is the single quote, which is escaped by placing two single quotes in a row."],["maybe_log_plan","Log a query plan if the `log_query_plans` feature is enabled and it hasn't been logged yet."],["repeat_display","Construct a RepeatDisplay that will repeatedly call `fmt_one` with a formatter `count` times, separated by `sep`."],["repeat_multi_values","Returns a value that formats as `num_values` instances of `(?,?,?,...)` (where there are `vars_per_value` question marks separated by commas in between the `?`s)."],["repeat_sql_values","Returns a value that formats as `count` instances of `(?)` separated by commas."],["repeat_sql_vars","Returns a value that formats as `count` instances of `?` separated by commas."]],"mod":[["conn_ext",""],["each_chunk",""],["interrupt",""],["maybe_cached",""],["query_plan",""],["repeat",""]],"struct":[["Conn",""],["QueryPlan",""],["QueryPlanStep",""],["RepeatDisplay","Helper type for printing repeated strings more efficiently. You should use `repeat_display`, or one of the `repeat_sql_*` helpers to construct it."],["SqlInterruptHandle","A Sync+Send type which can be used allow someone to interrupt an operation, even if it happens while rust code (and not SQL) is executing."],["SqlInterruptScope","A helper that can be used to determine if an interrupt request has come in while the object lives. This is used to avoid a case where we aren't running any queries when the request to stop comes in, but we're still not done (for example, maybe we've run some of the autocomplete matchers, and are about to start running the others. If we rely solely on sqlite3_interrupt(), we'd miss the message that we should stop)."],["UncheckedTransaction","rusqlite, in an attempt to save us from ourselves, needs a mutable ref to a connection to start a transaction. That is a bit of a PITA in some cases, so we offer this as an alternative - but the responsibility of ensuring there are no concurrent transactions is on our head."]],"trait":[["ConnExt","This trait exists so that we can use these helpers on `rusqlite::{Transaction, Connection}`. Note that you must import ConnExt in order to call these methods on anything."]]});